#!/bin/bash
#
# Start up script.
#
# About lockfile:
#   Usage:
#     lockfile -sleeptime | -r retries |
#              -l locktimeout | -s suspend | -!  | -ml | -mu | filename ...
#
# About trap:
#   Usage:
#     trap <'command'> <Signal-list>
#   Signal:
#     0  EXIT  Own exit signal.
#     1  HUP   Hang up (to reboot).
#     2  INT   Interrupt (Ctrl+c).
#     3  QUIT  Quit signal (create coredump).
#     9  KILL  Force quit (non-catchable, non-ignorable kill).
#     15 TERM  Default (software termination signal).
#     18 CONT  Continue.
#     19 STOP  Suspend.
#     20 TSTP  Suspend (Ctrl+Z).

CPID=$$
CWD=$(cd "$(dirname "$0")" && pwd)
PROG=$(basename "$0")
LOCKFILE="$CWD/$PROG".lock
PIDFILE="$CWD/$PROG".pid

PNAME_FOR_PGREP="$0 start"

start() {
    "$CWD/melty_blood_bot.py" "$@"
}

stop() {
    # Check status.
    status && return 0

    # Get pid.
    local pid
    if [ -e "$PIDFILE" ]; then
        pid=$(cat "$PIDFILE")
    fi

    # Kill the process.
    if [ -n "$pid" ]; then
        echo "kill $pid"
        kill $pid && return 0
    fi
    return 1
}

# See if the process is already running.
status() {
    # Check lock file.
    if [ -e "$LOCKFILE" ]; then
        echo "Lock file exists: $LOCKFILE" 1>&2
    fi

    # Check pid file.
    local pid
    if [ -e "$PIDFILE" ]; then
        pid=$(cat "$PIDFILE")
        echo "Pid file exists (pid=$pid): $PIDFILE" 1>&2
        if [ -n "$pid" ]; then
            if (ps -e | awk '{print $1}' | grep "$pid" >/dev/null); then
                echo "The process(pid=$pid) is already running." 1>&2
            else
                echo "The process(pid=$pid) is not running." 1>&2
            fi
        else
            echo "Pid is not found in pid file." 1>&2
        fi
    fi

    # Check the process with pgrep.
    if type pgrep > /dev/null 2>&1; then
        local pid_list
        pid_list=$(pgrep -fl "$PNAME_FOR_PGREP")
        pid_list=$(echo "$pid_list" | grep -v "^ *$CPID ")
        if [ -n "$pid" ]; then
            pid_list=$(echo "$pid_list" | grep -v "^ *$pid ")
        fi
        if [ -n "$pid_list" ]; then
            echo "Check other process..." 1>&2
            echo "The following process is running:" 1>&2
            echo "$pid_list" 1>&2
        fi
    fi

    # Check the result.
    if [ ! -e "$LOCKFILE" -a ! -e "$PIDFILE" -a -z "$pid_list" ]; then
        echo "The process is not running."
        return 0
    fi
    return 1
}

create_lock_pid_file() {
    # Check status.
    status > /dev/null || return 1

    # Create lock file.
    if type lockfile > /dev/null 2>&1; then
        lockfile -r 0 $LOCKFILE || return 1
    else
        touch "$LOCKFILE" || return 1
    fi

    # Create pid file.
    echo "$CPID" > "$PIDFILE"
    return 0
}

cleanup() {
    rm -f "$LOCKFILE"
    rm -f "$PIDFILE"
}


# See how we were called.
RET=0
ARG1=$1
shift
case "$ARG1" in
    start)
        # Create lock file.
        create_lock_pid_file
        if [ $? -ne 0 ] ; then
            echo 'Could not run the process!!' 1>&2
            exit 1
        fi
        # Setup trap.
        trap 'echo "...Traped." 1>&2; cleanup; exit 1;' 1 2 3 15

        start "$@" || RET=1

        # Clean up.
        cleanup || RET=1
        ;;
    stop)
        stop || RET=1
        ;;
    status)
        status || RET=1
        ;;
    restart)
        stop && start || RET=1
        ;;
    *)
      echo $"Usage: $PROG [start|stop|status]"
      RET=1
esac

exit $RET

